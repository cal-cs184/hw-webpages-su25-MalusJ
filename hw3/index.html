<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: Yuanbo Jiang</div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p><b>Walk through the ray generation and primitive intersection parts of the rendering pipeline.</b></p>
		For camera ray generation, the function first takes in a normalized (x,y) coordinate as input. And it outputs a ray in the world space. The way it is achieved can be break down into the following steps:
		<ul>
					<li><b>Convert FoVs to Radians:</b>Convert the horizontal and vertical field of view from degrees to radians to set up for calcualtions.</li>
					<li><b>Compute sensor plane:</b>Then it computes the sensor plane's size. The formula is <i>width = 2 * tan(hFov_rad / 2)</i> and <i>height = 2 * tan(vFov_rad / 2)</i></i></li>
					<li><b>Map normalized coordinates to sensor coordinates:</b> The next step is to shift (x,y) from the range [0,1] making (0.5, 0.5) at the center, and then scale by the sensor dimensions to get the x,y coordinates on sensor.</li>
					<li><b>Compute Ray direction in camera space:</b>By constructing a vector from the camera origin(0,0,0) through the point(by sensorX & sensorY) on the sensor plane and normalizing, we get the ray direction.</li>
					<li><b>Transform to world space:</b> Finally, we rotate the camera space direction vector into world space using the given c2w matrix, and then we normalize the result. And in the end, the function creates a ray object with camera position, direction, min_t and max_t, and return the result. </li>
		</ul>
		<div style="display: flex; justify-content: center; gap: 20px; align-items: center;">
			<div style="text-align: center;">
			<img src="CBempty.png" width="300px"/>
			<figcaption> </figcaption>
			</div>
		<div style="text-align: center;">
			<img src="banana.png" width="300px"/>
			<figcaption> </figcaption>
		</div>
		<div style="text-align: center;">
			<img src="task3.png" width="300px"/>
			<figcaption> </figcaption>
		</div>
		</div>
		
		<p>In primitive intersection stage of the pipeline, the function determines whether a ray hits any of the scene's geometric primitives, triangles and spheres in this case. The process is done by using the Moller-Trumbore Algorithm. It is a effective tool to check whether a ray intersects with a triangle and it also provides the coordinates if they do intersect. So we first perform the intersection tests within ray's valid range. When a closer hit is found, the function updates the ray's maximum allowable distance (max_t). When a valid hit occurs, the intersection record is filled with details including the hit distance, a pointer to the primitive, the bsdf material, and the surface normal at the hit point. The primitives, triangles and spheres, each have their own intersection functions which I will be discusisng below.</p>
		
		<p><b>Triangle Intersection Algorithm explanation: </b></p>
		<p>In the path tracer, we use the Moller-Trumbore algorithm to test whether a ray intersects a triangle in the scene. The algorithm takes in three points defining the triangle. In the function, we first do a quick check to see whether they are parallel, if so return false since they would not intersectt. Then we use barycentric coordinates to see if the point of intersection is inside the triangle. We also know whether where it happens if it is inside.</p>
		
		<p><b>Show images with normal shading for a few small .dae files. </b></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="coil.png" width="400px"/>
				  <figcaption>CBcoil.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres.png" width="400px"/>
				  <figcaption>CBspheres.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny.png" width="400px"/>
				  <figcaption>CBbunny.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="gems.png" width="400px"/>
				  <figcaption>gems.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		<p><b>Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.</b></p>
		To speed up ray tracing, I build a bounding volume hierachy using recursive algorithm. The constriction starts with a list of all primitives in the scene. Then it computes a bounding box t hat contains all of them. The spliting algorithm could be describe as steps below
		<ul>
			<li>Calculate the bounding box of all the centroids of the primitives</li>
			<li>choose the longest axis of that centroid box</li>
			<li>sort the primitives by their centroid positions along the axis</li>
			<li>And split them into two halfs</li>
		</ul>
		The approach is simple and fast, and it creates balances trees where each node has close amount of primitives.
		<figure>
			<img src="BVH.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>BVH example</figcaption>
		</figure>
		
		
		<p><b>Triangle Intersection Algorithm explanation: </b></p>
		<p>In the path tracer, we use the Moller-Trumbore algorithm to test whether a ray intersects a triangle in the scene. The algorithm takes in three points defining the triangle. In the function, we first do a quick check to see whether they are parallel, if so return false since they would not intersectt. Then we use barycentric coordinates to see if the point of intersection is inside the triangle. We also know whether where it happens if it is inside.</p>
		
		<p><b>how images with normal shading for a few large .dae files that you can only render with BVH acceleration</b></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lucy.png" width="400px"/>
				  <figcaption>CBlucy</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="cow.png" width="400px"/>
				  <figcaption>cow</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="max.png" width="400px"/>
				  <figcaption>maxplanck</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="walle.png" width="400px"/>
				  <figcaption>wall-e</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p><b>Compare rendering time:</b></p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="max1.png" width="400px"/>
				  <figcaption>MaxPlanck without BVH</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="max2.png" width="400px"/>
				  <figcaption>MaxPlanck with BVH</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny1.png" width="400px"/>
				  <figcaption>bunny without BVH</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny2.png" width="400px"/>
				  <figcaption>Bunny with BVH</figcaption>
				</td>
			  </tr>
			</table>
		</div>
<p>With BVH enabled, the rendering performance improved dramatically. As seen in the logs, the version without BVH takes more than 283 seconds and averaged over 7457 intersection tests per ray. In contrast, the BVH-enabled version completed rendering in just 0.092 seconds, averaging only 3.2 intersection tests per ray! And as we can see that the total number of rays traced is similar between both versions which is expected behavior. BVH is proved to be effective tool to accelerate the rendering.</p>

		<h2>Part 3: Direct Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 4: Global Illumination</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Part 6: Extra Credit Opportunities</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>